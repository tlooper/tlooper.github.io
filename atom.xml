<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SUP project</title>
  
  <subtitle>site-main</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://https://tlooper.github.io/"/>
  <updated>2019-01-22T16:43:37.128Z</updated>
  <id>https://https://tlooper.github.io/</id>
  
  <author>
    <name>Time Looper</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sup-extra HDU-1402 A*B Problem Plus  FFT模板题</title>
    <link href="https://https://tlooper.github.io/HDU-1402%20A%20%20B%20Problem%20Plus%20%20FFT/"/>
    <id>https://https://tlooper.github.io/HDU-1402 A  B Problem Plus  FFT/</id>
    <published>2019-01-22T16:43:31.000Z</published>
    <updated>2019-01-22T16:43:37.128Z</updated>
    
    <content type="html"><![CDATA[<p>#<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1402" target="_blank" rel="noopener">HDU-1402</a> A*B Problem Plus  FFT模板题</p><hr><p>　　题目就是一个大数乘法，由于位数长度达到了50000级别所以不能用常规写法，需要使用FFT解题。<br>　　那么首先需要知道的问题是，FFT是什么，是拿来干什么的？</p><blockquote><p><strong>FFT，即为快速傅氏变换，是离散傅氏变换的快速算法，它是根据离散傅氏变换的奇、偶、虚、实等特性，对离散傅立叶变换的算法进行改进获得的。</strong></p></blockquote><p>看上去很复杂，但实际上我们使用FFT是要解决的就是多项式乘法。多项式的表示有两种：</p><p>1.系数表示法，形如f(x)=a~0~+a~1~X+a~2~X^2^+…a~n~X^n^，其中告诉你所有的a的值，就是系数表示法</p><p>2.点值表示法，利用(x~0~,y~0~) (x~1~,y~1~)…(X~n~,y~n~)这么n个点来约束的n次多项式，你知道所有的x,y的值，就是点值表示法</p><p>如果F(x)=f(x)<em>g(x) 那么F(x~0~)=f(x~0~) </em> g(x~0~)  这个结论看上去就很自然。所以对于n+1个点我们都可以通过算出来的f(x) g(x)求出相应的F(x)。也就是说我们只要知道f(x) g(x)的点值表示法，算出n+1个点，就能得到乘法乘出来的F(x) 函数的点值表示法。</p><p>所以为了求出点值表示法的函数，我们就需要先找n+1个x的值出来。为了便于计算x^k^ 我们选取的就是复数平面上单位元的点，这样k次方得到的就是1了。FFT实现的就是<strong>把系数表示法变成点值表示法，把点值表示法变成系数表示法</strong>。</p><p>至于FFT可以变成2个DFT啊、求和的分治算法为了防止爆栈而变成下标反向的循环运算啊、IDFT和DFT之间只差一个1/n这种细节就不用理解了，还有诸如“你把一个函数扩展到了复数平面上后结果要是有虚部怎么办的问题”啊，我只能说理论上两个纯实部的函数就算代进虚部的函数值生成的新函数也不会产生有虚部的变量，至于为什么只能说是一些奇妙的性质了，<strong>总之明白了FFT是把什么东西变成了什么之后你甚至不用知道原理，拿着板子用就行。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1402&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HDU-1402&lt;/a&gt; A*B Problem Plus  FFT模板题&lt;/p&gt;
&lt;hr&gt;
&lt;
      
    
    </summary>
    
    
      <category term="ICPC" scheme="https://https://tlooper.github.io/tags/ICPC/"/>
    
  </entry>
  
  <entry>
    <title>sup-extra CodeForce-1009E Dominant Indices 启发式合并</title>
    <link href="https://https://tlooper.github.io/CodeForce-1009F%20Dominant%20Indices%20%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    <id>https://https://tlooper.github.io/CodeForce-1009F Dominant Indices 启发式合并/</id>
    <published>2019-01-21T04:00:00.000Z</published>
    <updated>2019-01-22T16:36:41.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CodeForce-1009F-Dominant-Indices-启发式合并"><a href="#CodeForce-1009F-Dominant-Indices-启发式合并" class="headerlink" title="CodeForce-1009F Dominant Indices 启发式合并"></a><a href="http://codeforces.com/problemset/problem/1009/F" target="_blank" rel="noopener">CodeForce-1009F</a> Dominant Indices 启发式合并</h1><hr><p><del>写这个题的时候至少进行了一亿次心理博弈……</del></p><p>　　题意大致为：对以节点x为根形成的子树，找到节点最多的层数，要是有多个数值相同就取最小的。</p><p>虽然看得出来是启发式合并解法，但是写的时候对于到底要怎么更新存储的最大值和结果一直没想明白……一开始写的是在求完所有的点之后遍历一遍去找最大的值，但是发现当树过长的时候时间复杂度是O(N!）……翻了很多博客都是寻找重儿子后进行一次交换，保留重儿子的结果再进行加，于是我开始思考我能不能在 每次遇到比我的层数多的子树时，交换子树统计的每层点的个数，同时拿过来子树的最大值呢。</p><p>我原本的想法：</p><p>要是我现在的最大层为a1,交换后成了一个比它小的b1，然后加的时候没遇到a1这一层那最大值不就错了嘛。</p><p>然后发现既然能进行交换那进行合并的时候肯定会更新a1这一层的值……因为交换了之后还要把原本的各层加回去……</p><p>稍微更改一下思路就过了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxl 1000006</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,res[maxl],most[maxl];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cal[maxl];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[maxl];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> depth,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cal[s][depth]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tree[s].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=tree[s][i];</span><br><span class="line">        <span class="keyword">if</span>(v==e) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v,depth+<span class="number">1</span>,s);</span><br><span class="line">        <span class="keyword">if</span>(cal[s].size()&lt;cal[v].size())</span><br><span class="line">        &#123;</span><br><span class="line">            swap(cal[s],cal[v]);</span><br><span class="line">            most[s]=most[v];</span><br><span class="line">            res[s]=res[v]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it=cal[v].begin();it!=cal[v].end();it++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=it-&gt;first;</span><br><span class="line">            cal[s][tmp]+=it-&gt;second;</span><br><span class="line">            <span class="keyword">if</span>(cal[s][tmp]&gt;most[s])</span><br><span class="line">            &#123;</span><br><span class="line">                res[s]=tmp-depth;</span><br><span class="line">                most[s]=cal[s][tmp];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cal[s][tmp]==most[s]&amp;&amp;res[s]&gt;(tmp-depth))</span><br><span class="line">                res[s]=tmp-depth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">memset</span>(res,<span class="number">0</span>,<span class="keyword">sizeof</span>(res));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            most[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tree[i].clear();</span><br><span class="line">            cal[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">            tree[a].push_back(b);</span><br><span class="line">            tree[b].push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CodeForce-1009F-Dominant-Indices-启发式合并&quot;&gt;&lt;a href=&quot;#CodeForce-1009F-Dominant-Indices-启发式合并&quot; class=&quot;headerlink&quot; title=&quot;CodeForce-1009F 
      
    
    </summary>
    
    
      <category term="ICPC" scheme="https://https://tlooper.github.io/tags/ICPC/"/>
    
  </entry>
  
  <entry>
    <title>sup-extra CodeForces-600E  Lomsat gelral 启发式合并</title>
    <link href="https://https://tlooper.github.io/CodeForces%20600E%20%20Lomsat%20gelral%20%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    <id>https://https://tlooper.github.io/CodeForces 600E  Lomsat gelral 启发式合并/</id>
    <published>2019-01-20T04:00:00.000Z</published>
    <updated>2019-01-22T16:42:24.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CodeForces-600E-Lomsat-gelral-启发式合并"><a href="#CodeForces-600E-Lomsat-gelral-启发式合并" class="headerlink" title="CodeForces-600E  Lomsat gelral 启发式合并"></a><a href="http://codeforces.com/problemset/problem/600/E" target="_blank" rel="noopener">CodeForces-600E</a>  Lomsat gelral 启发式合并</h1><hr><p>　　题意就是将一棵树的节点涂色，数目最多的颜色就是主导色，然后要求输出每一个点的主导色，如果有多个主导色就输出主导色的和。</p><p>　　解法参考了他人代码，具体思路即首先存储每个子树的颜色，然后再按照颜色出现次数维护sum，再存储最大次数的sum值。由于是树所以遍历回去之后不用考虑子树的状态，可以放心地调换color和sum。调换之后就能保证是将少的一组值合并到多的一组值里面去，即启发式合并的思想。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxl 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; color[maxl];</span><br><span class="line"><span class="comment">//color[x][y]:x= vertex number,y=color,val=color-sum;</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span> &gt;sum[maxl];</span><br><span class="line"><span class="comment">//sum[x][y]:x=vertex number,y=color-sum,val=res;</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[maxl];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res[maxl];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tree[s].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=tree[s][i];</span><br><span class="line">        <span class="keyword">if</span>(v==e) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v,s);</span><br><span class="line">        <span class="keyword">if</span>(color[s].size()&lt;color[v].size())</span><br><span class="line">        &#123;</span><br><span class="line">            swap(color[s],color[v]);</span><br><span class="line">            swap(sum[s],sum[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it=color[v].begin();it!=color[v].end();it++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[s][color[s][it-&gt;first]]-=it-&gt;first;<span class="comment">//sub color</span></span><br><span class="line">            color[s][it-&gt;first]+=it-&gt;second;<span class="comment">//change color-sum</span></span><br><span class="line">            sum[s][color[s][it-&gt;first]]+=it-&gt;first;<span class="comment">//add color</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res[s]=sum[s].rbegin()-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tree[i].clear();</span><br><span class="line">            color[i].clear();</span><br><span class="line">            sum[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c);</span><br><span class="line">            color[i][c]=<span class="number">1</span>;</span><br><span class="line">            sum[i][<span class="number">1</span>]=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">            tree[a].push_back(b);</span><br><span class="line">            tree[b].push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld "</span>,res[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res[n]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CodeForces-600E-Lomsat-gelral-启发式合并&quot;&gt;&lt;a href=&quot;#CodeForces-600E-Lomsat-gelral-启发式合并&quot; class=&quot;headerlink&quot; title=&quot;CodeForces-600E  Lomsa
      
    
    </summary>
    
    
      <category term="ICPC" scheme="https://https://tlooper.github.io/tags/ICPC/"/>
    
  </entry>
  
  <entry>
    <title>sup-extra HDU-1512 Monkey King 左偏树</title>
    <link href="https://https://tlooper.github.io/HDU-1512%20Monkey%20King%20%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
    <id>https://https://tlooper.github.io/HDU-1512 Monkey King 左偏树/</id>
    <published>2019-01-19T07:00:00.000Z</published>
    <updated>2019-01-22T16:41:03.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HDU-1512-Monkey-King-左偏树"><a href="#HDU-1512-Monkey-King-左偏树" class="headerlink" title="HDU-1512 Monkey King 左偏树"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1512" target="_blank" rel="noopener">HDU-1512</a> Monkey King 左偏树</h1><hr><p>　　题意是每次有两只猴子要battle，但是猴子battle的时候会叫自己认识的攻击力最高的猴子，并且battle结束后参加battle的猴子攻击力减半。</p><p>　　可以看出来这题就是要你维护两个优先队列，每次battle时弹出攻击力最高的，然后将攻击力减半再重新合并成一个新的队列。为了支持合并操作选用左偏树来实现。唯一需要注意的问题就是要记得更新你询问的节点的左偏树的根节点。<del>另外之前因为没有使用memset导致MLE，意义不明</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxl 100003</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> root[maxl],lef[maxl],rig[maxl],val[maxl],dist[maxl];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> k)</span><span class="comment">//寻找目前的左偏树根节点的同时更新沿途的节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root[k]==k) <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> root[k]=findroot(root[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ltree_merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//左偏树合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>||y==<span class="number">0</span>) <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">if</span>(val[x]&lt;val[y]) swap(x,y);</span><br><span class="line">    rig[x]=ltree_merge(rig[x],y);</span><br><span class="line">    root[rig[x]]=x;</span><br><span class="line">    <span class="keyword">if</span>(dist[rig[x]]&gt;dist[lef[x]])</span><br><span class="line">        swap(rig[x],lef[x]);</span><br><span class="line">    <span class="keyword">if</span>(rig[x]==<span class="number">0</span>)</span><br><span class="line">        dist[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> dist[x]=dist[rig[x]]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ltree_pop</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//左偏树删除根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l1=lef[a],l2=lef[b],r1=rig[a],r2=rig[b];</span><br><span class="line">    root[l1]=l1;root[l2]=l2;root[r1]=r1;root[r2]=r2;</span><br><span class="line">    lef[a]=rig[a]=lef[b]=rig[b]=dist[a]=dist[b]=<span class="number">0</span>;</span><br><span class="line">    val[a]/=<span class="number">2</span>;val[b]/=<span class="number">2</span>;</span><br><span class="line">    a=ltree_merge(a,b);</span><br><span class="line">    b=ltree_merge(l1,r1);</span><br><span class="line">    a=ltree_merge(a,b);</span><br><span class="line">    b=ltree_merge(l2,r2);</span><br><span class="line">    <span class="keyword">return</span> ltree_merge(a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(root,<span class="number">0</span>,<span class="keyword">sizeof</span>(root));</span><br><span class="line">        <span class="built_in">memset</span>(lef,<span class="number">0</span>,<span class="keyword">sizeof</span>(lef));</span><br><span class="line">        <span class="built_in">memset</span>(rig,<span class="number">0</span>,<span class="keyword">sizeof</span>(rig));</span><br><span class="line">        <span class="built_in">memset</span>(dist,<span class="number">0</span>,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val[i]);</span><br><span class="line">        root[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid1,mid2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;mid1,&amp;mid2);</span><br><span class="line">        findroot(mid1);</span><br><span class="line">        findroot(mid2);</span><br><span class="line">        <span class="keyword">if</span>(root[mid1]==root[mid2])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res;</span><br><span class="line">            res=ltree_pop(root[mid1],root[mid2]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,val[res]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HDU-1512-Monkey-King-左偏树&quot;&gt;&lt;a href=&quot;#HDU-1512-Monkey-King-左偏树&quot; class=&quot;headerlink&quot; title=&quot;HDU-1512 Monkey King 左偏树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http:
      
    
    </summary>
    
    
      <category term="ICPC" scheme="https://https://tlooper.github.io/tags/ICPC/"/>
    
  </entry>
  
  <entry>
    <title>sup-extra HYSBZ-2809 dispatching 左偏树</title>
    <link href="https://https://tlooper.github.io/HYSBZ-2809%20dispatching%20%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
    <id>https://https://tlooper.github.io/HYSBZ-2809 dispatching 左偏树/</id>
    <published>2019-01-19T04:00:00.000Z</published>
    <updated>2019-01-22T16:42:51.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HYSBZ-2809-dispatching-左偏树"><a href="#HYSBZ-2809-dispatching-左偏树" class="headerlink" title="HYSBZ-2809 dispatching 左偏树"></a><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2809" target="_blank" rel="noopener">HYSBZ-2809</a> dispatching 左偏树</h1><p>　　题意就是要找一棵子树满足薪水和小于总预算的同时，节点数*子树根的领导力要最大。</p><p>　　解题的思路就是对树的每个节点都存储它的薪水和，如果超出了总预算就弹出最大的点。同时因为是DFS，所以回到高层之后就不用管底层的节点的状态了。同时为了能弹出最大的点，不能只存储薪水和，应当保留所有的薪水值，但是使用优先队列又不能快速合并两个优先队列，所以考虑使用可并堆左偏树。</p><p>　　至于什么是左偏树……<del>就是左倾的树（迫真）</del>总之只要会用板子就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxl 1000006</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[maxl];</span><br><span class="line"><span class="keyword">int</span> val[<span class="number">1000006</span>],lead[<span class="number">1000006</span>];</span><br><span class="line"><span class="keyword">int</span> lef[maxl],rig[maxl],dist[maxl],root[maxl];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[maxl],coun[maxl];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ltree_merge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//左偏树的合并操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>||b==<span class="number">0</span>) <span class="keyword">return</span> a+b;</span><br><span class="line">    <span class="keyword">if</span>(val[a]&lt;val[b]) swap(a,b);</span><br><span class="line">    rig[a]=ltree_merge(rig[a],b);</span><br><span class="line">    root[rig[a]]=a;</span><br><span class="line">    <span class="keyword">if</span>(dist[rig[a]]&gt;dist[lef[a]])</span><br><span class="line">        swap(rig[a],lef[a]);</span><br><span class="line">    <span class="keyword">if</span>(rig[a]==<span class="number">0</span>)</span><br><span class="line">        dist[a]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> dist[a]=dist[rig[a]]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ltree_pop</span><span class="params">(<span class="keyword">int</span> k)</span><span class="comment">//左偏树删除顶点的操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=lef[k],r=rig[k];</span><br><span class="line">    root[l]=l;root[r]=r;</span><br><span class="line">    lef[k]=rig[k]=dist[k]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ltree_merge(l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tree[k].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=tree[k][i];</span><br><span class="line">        dfs(v);</span><br><span class="line">        sum[k]+=sum[v];</span><br><span class="line">        coun[k]+=coun[v];</span><br><span class="line">        root[k]=root[v]=ltree_merge(root[k],root[v]);<span class="comment">//将两个子树合成一个</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(sum[k]&gt;m)<span class="comment">//维护k点的左偏树</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum[k]-=val[root[k]];</span><br><span class="line">        root[k]=ltree_pop(root[k]);</span><br><span class="line">        coun[k]--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    res=max(res,coun[k]*lead[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> fa;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;fa,&amp;val[i],&amp;lead[i]);</span><br><span class="line">            tree[fa].push_back(i);<span class="comment">//建树</span></span><br><span class="line">            root[i]=i;</span><br><span class="line">            coun[i]=<span class="number">1</span>;</span><br><span class="line">            sum[i]=val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        res=<span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HYSBZ-2809-dispatching-左偏树&quot;&gt;&lt;a href=&quot;#HYSBZ-2809-dispatching-左偏树&quot; class=&quot;headerlink&quot; title=&quot;HYSBZ-2809 dispatching 左偏树&quot;&gt;&lt;/a&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="ICPC" scheme="https://https://tlooper.github.io/tags/ICPC/"/>
    
  </entry>
  
  <entry>
    <title>sup-002 利用python执行C程序</title>
    <link href="https://https://tlooper.github.io/sup-002/"/>
    <id>https://https://tlooper.github.io/sup-002/</id>
    <published>2018-11-14T13:37:39.000Z</published>
    <updated>2018-11-14T16:03:02.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用python执行C程序"><a href="#利用python执行C程序" class="headerlink" title="利用python执行C程序"></a>利用python执行C程序</h1><p>　　首先python自己是无法真正意义上地去执行C语言的代码的，但是我们可以转换思路，利用python调用外部程序来实现。</p><h2 id="0-配置环境变量"><a href="#0-配置环境变量" class="headerlink" title="0.配置环境变量"></a>0.配置环境变量</h2><p>　　由于需要调用编译器进行程序的编译运行，故需要在环境变量path中添加编译器地址。</p><blockquote><p>如何找到编译器地址？以codeblocks 为例：在 \CodeBlocks\MinGW\bin 目录下有g++.exe,其他编译器自行手动搜索</p></blockquote><p>　　配置环境变量：此电脑-&gt;属性-&gt;(左侧栏的)高级系统设置-&gt;高级-&gt;环境变量<br>　　双击Path，添加编译器的地址在最后</p><h2 id="1-subprocess-call"><a href="#1-subprocess-call" class="headerlink" title="1.subprocess.call()"></a>1.subprocess.call()</h2><blockquote><p>虽然有个os的模块同样有os.system()函数来实现执行命令行的操作，但是似乎目前已经被subprocess取代了，同时subprocess 模块的使用灵活度比os大得多，所以在此只介绍使用subprocess模块的情况</p></blockquote><p>　　<strong>如果是Linux系统请下载subprocess32,<code>sudo pip install subprocess32</code></strong></p><p>　　显然使用这个函数需要包含<code>subprocess</code>的模块，括号中包含的字符串就是你平时在命令提示符窗口输入的指令，除了字符串似乎还支持list<del>不过我不需要</del>。如果是用codeblocks的话可以看到，在编译运行的时候，运行日志的前两行输出了命令行，代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">subprocess.call(<span class="string">"mingw32-gcc.exe   -c test.c -o test.o"</span>)</span><br><span class="line">subprocess.call(<span class="string">"mingw32-g++.exe  -o test.exe test.o"</span>)</span><br></pre></td></tr></table></figure><p>　　Linux下的代码：（确保已经安装g++/gcc）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subprocess.call(<span class="string">"g++ test.cpp -o test"</span>)</span><br></pre></td></tr></table></figure><p>　　当然光是编译运行是不够的，我们要能执行C程序，还要提供输入与输出。如果是直接用<code>subprocess.call(&quot;test.exe&quot;)</code>，系统默认的输入输出跟python程序的输入输出一样。我们也可以指定从文件输入输出<del>就像是打ACM一样</del>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">inp=open(<span class="string">"in.txt"</span>,<span class="string">"r"</span>)</span><br><span class="line">out=open(<span class="string">"res.txt"</span>,<span class="string">"w"</span>)</span><br><span class="line">subprocess.call(<span class="string">"test.exe"</span> , stdin=inp,stdout=out)</span><br></pre></td></tr></table></figure><p>　　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用python执行C程序&quot;&gt;&lt;a href=&quot;#利用python执行C程序&quot; class=&quot;headerlink&quot; title=&quot;利用python执行C程序&quot;&gt;&lt;/a&gt;利用python执行C程序&lt;/h1&gt;&lt;p&gt;　　首先python自己是无法真正意义上地去执行C语
      
    
    </summary>
    
    
      <category term="skill" scheme="https://https://tlooper.github.io/tags/skill/"/>
    
  </entry>
  
  <entry>
    <title>introduction</title>
    <link href="https://https://tlooper.github.io/introduction/"/>
    <id>https://https://tlooper.github.io/introduction/</id>
    <published>2018-09-10T12:15:47.000Z</published>
    <updated>2018-09-14T10:54:31.505Z</updated>
    
    <content type="html"><![CDATA[<p>“    <strong>人类到如今已经繁衍了250000年，只有最近的100年是有网络的。</strong><br>    所以，我们在将近250000年中在干嘛？我们用最原始的方式交流、学习，信息在传递中改变、散佚，我们无从得知曾经有过怎样的技术、知识，事实与传说混杂在一起。<br>之后，网络将人类连接起来，人与人之间的信息交流从未如此快速、准确。人类过剩的创造力带来了数不胜数的信息片段，部分片段随着时间推移也如传说般变得模糊不清。<br>    <strong>人类不能再生活在信息匮乏的笼子里。</strong>如果信息获取被阻止，我们就创造信息。<br>    当他人甘于无知时，我们必须花时间搜集、创造知识，并将它们保存下来，寄希望于后人能接替我们的事业。<br><strong>我们搜集，我们理解，我们制造。</strong>”<br>——O5-T</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“    &lt;strong&gt;人类到如今已经繁衍了250000年，只有最近的100年是有网络的。&lt;/strong&gt;&lt;br&gt;    所以，我们在将近250000年中在干嘛？我们用最原始的方式交流、学习，信息在传递中改变、散佚，我们无从得知曾经有过怎样的技术、知识，事实与传说混杂在
      
    
    </summary>
    
    
      <category term="introduction" scheme="https://https://tlooper.github.io/tags/introduction/"/>
    
  </entry>
  
</feed>
