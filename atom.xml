<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SUP project</title>
  
  <subtitle>site-T</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tlooper.github.io/"/>
  <updated>2019-07-26T07:14:42.922Z</updated>
  <id>https://tlooper.github.io/</id>
  
  <author>
    <name>Time Looper</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sup-extra 代码模板</title>
    <link href="https://tlooper.github.io/sup-extra-ICPCtemplate/"/>
    <id>https://tlooper.github.io/sup-extra-ICPCtemplate/</id>
    <published>2019-07-26T07:14:00.000Z</published>
    <updated>2019-07-26T07:14:42.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="板子20197"><a class="markdownIt-Anchor" href="#板子20197"></a> 板子——2019.7</h1><h2 id="树论图论"><a class="markdownIt-Anchor" href="#树论图论"></a> 树论&amp;图论</h2><h3 id="网络流"><a class="markdownIt-Anchor" href="#网络流"></a> 网络流</h3><p>使用范围：主要解决的问题就是最大流（从源点到汇点的总量最大）和最小割（断掉最小权值的边使得源点不能到达汇点），似乎还能解决二分图的问题</p><p>思想：利用BFS判断每个点的深度，然后利用DFS算出每条链上的最小权值，每次修改的时候更新路上的所有边。使用的时候记得考虑建图。</p><p>代码板子：</p><p class="code-caption" data-lang="cpp" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    LL val;</span><br><span class="line">    Edge(<span class="keyword">int</span> _to,<span class="keyword">int</span> _val)&#123;to=_to;val=_val;&#125;</span><br><span class="line">    Edge()&#123;&#125;</span><br><span class="line">&#125;edge[maxn*<span class="number">2</span>];</span><br><span class="line">LL dis[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; flow[maxn];</span><br><span class="line"><span class="keyword">int</span> deep[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,LL c)</span></span>&#123;</span><br><span class="line">    edge[coun].to=y,edge[coun].val=c;</span><br><span class="line">    flow[x].push_back(coun++);</span><br><span class="line">    edge[coun].to=x,edge[coun].val=<span class="number">0</span>;</span><br><span class="line">    flow[y].push_back(coun++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxn;++i)&#123;</span><br><span class="line">        ori[i].clear();</span><br><span class="line">        flow[i].clear();</span><br><span class="line">        coun=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs_divide</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(deep,<span class="number">-1</span>,<span class="keyword">sizeof</span>(deep));</span><br><span class="line">    deep[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;flow[u].size();++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=flow[u][i];</span><br><span class="line">            <span class="keyword">int</span> v=edge[tmp].to;</span><br><span class="line">            LL val=edge[tmp].val;</span><br><span class="line">            <span class="keyword">if</span>(val&amp;&amp;deep[v]==<span class="number">-1</span>)&#123;</span><br><span class="line">                deep[v]=deep[u]+<span class="number">1</span>;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deep[t]!=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dfs_cut</span><span class="params">(<span class="keyword">int</span> u,LL val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==n) <span class="keyword">return</span> val;</span><br><span class="line">    LL res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;flow[u].size();++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=flow[u][i];</span><br><span class="line">        <span class="keyword">if</span>(edge[tmp].val&amp;&amp;deep[u]+<span class="number">1</span>==deep[edge[tmp].to])&#123;</span><br><span class="line">            LL mid=dfs_cut(edge[tmp].to,min(val,edge[tmp].val));</span><br><span class="line">            val-=mid;</span><br><span class="line">            res+=mid;</span><br><span class="line">            edge[tmp].val-=mid;</span><br><span class="line">            edge[tmp^<span class="number">1</span>].val+=mid;</span><br><span class="line">            <span class="keyword">if</span>(val==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">maxflow</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    LL res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs_divide(<span class="keyword">int</span> s,<span class="keyword">int</span> t))&#123;</span><br><span class="line">        res+=dfs_cut(s,INFL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dijkstra最短路"><a class="markdownIt-Anchor" href="#dijkstra最短路"></a> Dijkstra最短路</h3><p>使用范围：无负环的图</p><p>思想：每次优先选择的点都是离自己最近的点，由此得到的路径一定是最短的。</p><p>模板代码：</p><p class="code-caption" data-lang="cpp" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    LL val;</span><br><span class="line">    Edge(<span class="keyword">int</span> _to,<span class="keyword">int</span> _val)&#123;to=_to;val=_val;&#125;</span><br><span class="line">    Edge()&#123;&#125;</span><br><span class="line">&#125;edge[maxn*<span class="number">2</span>];</span><br><span class="line">LL dis[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; ori[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    LL dis;</span><br><span class="line">    Node(<span class="keyword">int</span> n,LL d):num(n),dis(d)&#123;&#125;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node&amp; b)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis&gt;b.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;Node&gt; q;</span><br><span class="line">    q.push(Node(<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.top().num;</span><br><span class="line">        LL tmp=q.top().dis;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="comment">//cout&lt;&lt;u&lt;&lt;' '&lt;&lt;tmp&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(dis[u]!=tmp) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> sz=ori[u].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=ori[u][i].to;</span><br><span class="line">            LL val=ori[u][i].val;</span><br><span class="line">            <span class="keyword">if</span>(dis[u]+val&lt;dis[v])&#123;</span><br><span class="line">                dis[v]=dis[u]+val;</span><br><span class="line">                q.push(Node(v,dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间数"><a class="markdownIt-Anchor" href="#区间数"></a> 区间数</h2><h3 id="数位dp"><a class="markdownIt-Anchor" href="#数位dp"></a> 数位DP</h3><p>使用范围：一段区间上满足条件的数的个数</p><p>思想：实际上也是先暴力模拟然后记忆化搜索</p><p>代码板子：</p><p class="code-caption" data-lang="cpp" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">LL posi[<span class="number">10</span>][<span class="number">2</span>];</span><br><span class="line">LL dig[<span class="number">20</span>];</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">bool</span> bef,<span class="keyword">bool</span> edge)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    LL sz= edge? dig[p]: <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span>(posi[p][bef]!=<span class="number">-1</span>&amp;&amp;!edge) <span class="keyword">return</span> posi[p][bef];<span class="comment">//边界特判</span></span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=sz;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">4</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">2</span>&amp;&amp;bef) <span class="keyword">continue</span>;</span><br><span class="line">        ans+=dfs(p<span class="number">-1</span>,i==<span class="number">6</span>,edge&amp;&amp;(i==sz));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!edge) posi[p][bef]=ans;<span class="comment">//边界特判</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">init</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dig,<span class="number">0</span>,<span class="keyword">sizeof</span>(dig));</span><br><span class="line">    <span class="keyword">while</span>(a)&#123;</span><br><span class="line">        dig[++i]=a%<span class="number">10</span>;</span><br><span class="line">        a/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL res= dfs(i,<span class="literal">false</span>,<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线段树"><a class="markdownIt-Anchor" href="#线段树"></a> 线段树</h3><p>使用范围：对区间内点的修改与区间修改，复杂度可以降低到 log(n) 级别。不过目前自己还是只会区间加乘与单点加乘</p><p>思想：二进制思想，分别记录区间1-n、 1-n/2、n/2+1-n等等，区间修改就往下找到区间，单点修改就找到点。并且区间的修改需要使用lazy标记，在下次遍历到更下面的区间时进行更新。</p><p>模板代码：(进行区间加法的)</p><p class="code-caption" data-lang="cpp" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,sum,tag;</span><br><span class="line">&#125;tree[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    tree[k].l=l,tree[k].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tree[k].sum=a[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(tree[k].l+tree[k].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(k&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    build(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    tree[k].sum=tree[k&lt;&lt;<span class="number">1</span>].sum+tree[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_tag</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[k].l==tree[k].r)&#123;</span><br><span class="line">        tree[k].sum+=tree[k].tag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tree[k].sum+=(tree[k].r-tree[k].l+<span class="number">1</span>)*tree[k].sum;</span><br><span class="line">        tree[k&lt;&lt;<span class="number">1</span>].tag+=tree[k].tag;</span><br><span class="line">        tree[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].tag+=tree[k].tag;</span><br><span class="line">    &#125;</span><br><span class="line">    tree[k].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[k].l==l&amp;&amp;tree[k].r==r) &#123;</span><br><span class="line">        tree[k].tag+=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[k].tag) change_tag(k);</span><br><span class="line">    tree[k].sum+=(r-l+<span class="number">1</span>)*x;</span><br><span class="line">    <span class="keyword">int</span> mid=(tree[k].l+tree[k].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid)&#123; add(k&lt;&lt;<span class="number">1</span>,l,r,x);&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid)&#123;add(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,x)&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;add(k&lt;&lt;<span class="number">1</span>,l,mid,x);</span><br><span class="line">         add(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[k].tag) change(k);</span><br><span class="line">    <span class="keyword">if</span>(tree[k].l==l&amp;&amp;tree[k].r==r) <span class="keyword">return</span> tree[k].sum;</span><br><span class="line">    <span class="keyword">int</span> mid=(tree[k].l+tree[k].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&gt;=mid) <span class="keyword">return</span> query(k&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> query(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(k&lt;&lt;<span class="number">1</span>,l,mid)+query(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主席树"><a class="markdownIt-Anchor" href="#主席树"></a> 主席树</h3><p>使用范围：需要知道过去状态的线段树</p><p>思想：可持久化线段树，存储每个修改前的线段树，因此一开始不能直接建树，一开始只能建一个空节点然后渐渐按照线段树的思想对其进行扩充。建议开到20*maxn。未被修改的子树会直接接到新的线段树的原位上，所以整体结构不如线段树那样整洁优美，导致不能通过下标确定子树位置，需要在节点信息中额外保存。另外进行区间修改的时候是不清空lazy的，通过累加路径上的lazy带来的影响，来修正结果，这样就可以减少往下递归的次数，生成更少的点，从而降低空间复杂度。</p><p class="code-caption" data-lang="cpp" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    LL lazy,sum;</span><br><span class="line">    <span class="keyword">int</span> ls,rs;</span><br><span class="line">&#125;tree[maxn*<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],tot,timestamp;</span><br><span class="line"><span class="comment">//kl kr用来标记区间</span></span><br><span class="line">LL ori[maxn], sum[maxn];;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_build</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    tree[k].lazy=<span class="number">0</span>;</span><br><span class="line">    tree[k].sum=sum[r]-sum[l<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    tree[k].ls=++tot;<span class="comment">//常规线段树的预先建树时会导致产生几个空点</span></span><br><span class="line">    tree[k].rs=++tot;<span class="comment">//毕竟都保存了左右儿子了就前序遍历建的紧凑一点吧，不然tot值会出错</span></span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    pre_build(tree[k].ls,l,mid);</span><br><span class="line">    pre_build(tree[k].rs,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_insert</span><span class="params">(<span class="keyword">int</span> kl,<span class="keyword">int</span> kr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> &amp;k,LL val)</span></span>&#123;</span><br><span class="line">    tree[++tot]=tree[k];</span><br><span class="line">    k=tot;<span class="comment">//修改K值以符合实际的新情况，连带修改K原来的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l==kl&amp;&amp;r==kr) &#123;</span><br><span class="line">        tree[k].lazy+=val;<span class="comment">//正好是区间的情况下只改lazy的值</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> tree[k].sum+=val*(r-l+<span class="number">1</span>);<span class="comment">//包含关系就要清楚的加上</span></span><br><span class="line">    <span class="keyword">int</span> mid=(kl+kr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) tree_insert(kl,mid,l,r,tree[k].ls,val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) tree_insert(mid+<span class="number">1</span>,kr,l,r,tree[k].rs,val);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tree_insert(kl,mid,l,mid,tree[k].ls,val);</span><br><span class="line">        tree_insert(mid+<span class="number">1</span>,kr,mid+<span class="number">1</span>,r,tree[k].rs,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> kl,<span class="keyword">int</span> kr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    LL res=tree[k].lazy*(r-l+<span class="number">1</span>);<span class="comment">//有lazy表示后面都被修改了，所以加上一个值</span></span><br><span class="line">    <span class="keyword">int</span> mid=(kl+kr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(kl==l&amp;&amp;kr==r) <span class="keyword">return</span> res+tree[k].sum;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) res+=query(kl,mid,l,r,tree[k].ls);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) res+=query(mid+<span class="number">1</span>,kr,l,r,tree[k].rs);</span><br><span class="line">    <span class="keyword">else</span> res+=query(kl,mid,l,mid,tree[k].ls)+query(mid+<span class="number">1</span>,kr,mid+<span class="number">1</span>,r,tree[k].rs);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同时还要在root数组中存储每个树的头，在生成新的树时root[i]=root[i-1]继承上个树的结果</span></span><br><span class="line"><span class="comment">//对root[i]的值的修改则是交给tree_insert函数进行的</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;板子20197&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#板子20197&quot;&gt;&lt;/a&gt; 板子——2019.7&lt;/h1&gt;
&lt;h2 id=&quot;树论图论&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#树论图论&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="ICPC" scheme="https://tlooper.github.io/tags/ICPC/"/>
    
  </entry>
  
  <entry>
    <title>sup-extra 主席树的原理及使用</title>
    <link href="https://tlooper.github.io/sup-extra-%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    <id>https://tlooper.github.io/sup-extra-主席树/</id>
    <published>2019-07-26T07:09:00.000Z</published>
    <updated>2019-07-27T02:34:39.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主席树的原理及使用"><a class="markdownIt-Anchor" href="#主席树的原理及使用"></a> 主席树的原理及使用</h1><h2 id="0前置知识"><a class="markdownIt-Anchor" href="#0前置知识"></a> 0.前置知识</h2><p>需要掌握线段树</p><h2 id="1-原理"><a class="markdownIt-Anchor" href="#1-原理"></a> 1. 原理</h2><p>​主席树即“可持久化线段树”，是存储每次修改时线段树状态的线段树，由于存储了每次的状态，所以可以进行对过去状态的回溯。</p><p>​目前来看，主席树除了可以解决对线段树的过去状态进行询问的问题，还能解决区间第K大即区间最值的快速查询，单次查询的时间复杂度是O(log<sub>2</sub>n)。整个主席树的空间复杂度可以达到O(2n+mlog<sub>2</sub>n),前面的2n是线段树的大小，后面的是每次修改增加的点数。对于每次修改，主席树需要把路径上经过的所有点进行修改并重新存储。嘛总之空间复杂度高的话开到20*maxn吧，由于主席树单个点的结构还挺简单的，这样往往也不会爆。</p><p>​那么要如何来构建一个主席树呢？<em>摸了,先留着吧</em>。总之就是待会看模板吧，先把题目放上来</p><h2 id="2具体题目"><a class="markdownIt-Anchor" href="#2具体题目"></a> 2.具体题目</h2><h3 id="hdu-2665"><a class="markdownIt-Anchor" href="#hdu-2665"></a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2665" target="_blank" rel="noopener">HDU-2665</a> Kth number - 区间第K小问题</h3><p>这个题题面说是第K大，就很菜，实际上是个第K小。</p><p class="code-caption" data-lang="cpp" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//结果这个题目骗我，自己明明是第K小</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls,rs,sum;</span><br><span class="line"><span class="comment">//求第k大的时候不需要区间信息就不存左右节点了</span></span><br><span class="line"><span class="comment">//正常情况下还是要像正常线段树一样存的</span></span><br><span class="line">    Node(<span class="keyword">int</span> l,<span class="keyword">int</span> r):ls(l),rs(r)&#123;&#125;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">&#125;tree[maxn*<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> coun,root[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_insert</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> &amp;k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    tree[++coun]=tree[k];<span class="comment">//先新建点继承原先的数据</span></span><br><span class="line">    k=coun;<span class="comment">//主要是为了修改父节点的左右儿子的值</span></span><br><span class="line">    tree[k].sum++;<span class="comment">//更新一下数据，如果有别的也要更新别的</span></span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> ;<span class="comment">//到叶子节点了</span></span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=mid)</span><br><span class="line">        tree_insert(num,tree[k].ls,l,mid);</span><br><span class="line">    <span class="keyword">else</span> tree_insert(num,tree[k].rs,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> before,<span class="keyword">int</span> after,<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//before 与after 存储的是前后两个线段树的头节点</span></span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> leftadd=tree[tree[after].ls].sum-tree[tree[before].ls].sum;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=leftadd)</span><br><span class="line">        query(tree[before].ls,tree[after].ls,k,l,mid);</span><br><span class="line">    <span class="keyword">else</span> query(tree[before].rs,tree[after].rs,k-leftadd,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,ori[maxn],discrete[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        tree[<span class="number">0</span>].sum=tree[<span class="number">0</span>].ls=tree[<span class="number">0</span>].rs=<span class="number">0</span>;</span><br><span class="line">        root[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;ori[i]);</span><br><span class="line">            discrete[i]=ori[i];</span><br><span class="line">        &#125;</span><br><span class="line">        coun=<span class="number">0</span>;</span><br><span class="line">        sort(discrete+<span class="number">1</span>,discrete+n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> newn=unique(discrete+<span class="number">1</span>,discrete+n+<span class="number">1</span>)-discrete<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            ori[i]=lower_bound(discrete+<span class="number">1</span>,discrete+newn+<span class="number">1</span>,ori[i])-discrete;</span><br><span class="line">            root[i]=root[i<span class="number">-1</span>];</span><br><span class="line">            tree_insert(ori[i],root[i],<span class="number">1</span>,newn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s,t,k,res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;s,&amp;t,&amp;k);</span><br><span class="line">            res=query(root[s<span class="number">-1</span>],root[t],k,<span class="number">1</span>,newn);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,discrete[res]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu-6601"><a class="markdownIt-Anchor" href="#hdu-6601"></a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6601" target="_blank" rel="noopener">HDU-6601</a> Keen On Everything But Triangle 区间第k大</h3><p>​题目看似是让你找能形成三角形的边，实际上就是在一个区间里从最大的边开始往下贪心。构不成三角形的最坏情况就是Fibonacci数列，Fibonacci数列递增的又很快，所以最多的情况是44个数都不能形成三角形，复杂度O(44*logn)，完全可以接受。</p><p class="code-caption" data-lang="cpp" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="comment">//正好用主席树试试吧</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls,rs,sum;</span><br><span class="line">&#125;tree[maxn*<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_insert</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">int</span> &amp;k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    tree[++tot]=tree[k];k=tot;</span><br><span class="line">    ++tree[k].sum;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=mid) tree_insert(num,tree[k].ls,l,mid);</span><br><span class="line">    <span class="keyword">else</span> tree_insert(num,tree[k].rs,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_big</span><span class="params">(<span class="keyword">int</span> bef,<span class="keyword">int</span> aft,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> rightadd=tree[tree[aft].rs].sum-tree[tree[bef].rs].sum;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=rightadd)</span><br><span class="line">        <span class="keyword">return</span> query_big(tree[bef].rs,tree[aft].rs,mid+<span class="number">1</span>,r,k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> query_big(tree[bef].ls,tree[aft].ls,l,mid,k-rightadd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ori[maxn];</span><br><span class="line">LL lisj[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("1011.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("test.txt","w",stdout);</span></span><br><span class="line">    <span class="keyword">int</span> n,q;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q))&#123;</span><br><span class="line">        tree[<span class="number">0</span>].ls=tree[<span class="number">0</span>].rs=tree[<span class="number">0</span>].sum=<span class="number">0</span>;</span><br><span class="line">        root[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        tot=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;ori[i]);</span><br><span class="line">            lisj[i]=ori[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(lisj+<span class="number">1</span>,lisj+<span class="number">1</span>+n);</span><br><span class="line">        <span class="keyword">int</span> newn=unique(lisj+<span class="number">1</span>,lisj+n+<span class="number">1</span>)-lisj<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            ori[i]=lower_bound(lisj+<span class="number">1</span>,lisj+<span class="number">1</span>+newn,ori[i])-lisj;</span><br><span class="line">            root[i]=root[i<span class="number">-1</span>];</span><br><span class="line">            tree_insert(ori[i],root[i],<span class="number">1</span>,newn);</span><br><span class="line">        &#125;</span><br><span class="line">        LL line[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            <span class="keyword">int</span> l,r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">            line[<span class="number">0</span>]=line[<span class="number">1</span>]=line[<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">            LL res=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r-l+<span class="number">1</span>;++i)&#123;</span><br><span class="line">                line[i%<span class="number">3</span>]=query_big(root[l<span class="number">-1</span>],root[r],<span class="number">1</span>,newn,i+<span class="number">1</span>);</span><br><span class="line">                LL a=lisj[line[i%<span class="number">3</span>]],b=lisj[line[(i+<span class="number">2</span>)%<span class="number">3</span>]],c=lisj[line[(i+<span class="number">1</span>)%<span class="number">3</span>]];</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=<span class="number">2</span>&amp;&amp;a+b&gt;c)&#123;</span><br><span class="line">                    res=a+b+c;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu-4348"><a class="markdownIt-Anchor" href="#hdu-4348"></a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=4348" target="_blank" rel="noopener">HDU-4348</a> To the moon 区间修改</h3><p>​题目一读就知道是版题呢，都告诉你要回溯了。这个题跟上面两个的不同就在于必须先建树，而不是像上面那样边插入点边建。同时建树不能按照线段树的二进制思想建，因为二进制思想建虽然方便但是中间会有空间的空隙，放在主席树当中这些空隙会让你不知道往哪放新建的点。</p><p class="code-caption" data-lang="cpp" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    LL lazy,sum;</span><br><span class="line">    <span class="keyword">int</span> ls,rs;</span><br><span class="line">&#125;tree[maxn*<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> root[maxn],tot,timestamp;</span><br><span class="line"><span class="comment">//kl kr用来标记区间</span></span><br><span class="line">LL ori[maxn], sum[maxn];;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_build</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    tree[k].lazy=<span class="number">0</span>;</span><br><span class="line">    tree[k].sum=sum[r]-sum[l<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    tree[k].ls=++tot;</span><br><span class="line">    tree[k].rs=++tot;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    pre_build(tree[k].ls,l,mid);</span><br><span class="line">    pre_build(tree[k].rs,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_insert</span><span class="params">(<span class="keyword">int</span> kl,<span class="keyword">int</span> kr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> &amp;k,LL val)</span></span>&#123;</span><br><span class="line">    tree[++tot]=tree[k];</span><br><span class="line">    k=tot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l==kl&amp;&amp;r==kr) &#123;</span><br><span class="line">        tree[k].lazy+=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> tree[k].sum+=val*(r-l+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> mid=(kl+kr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) tree_insert(kl,mid,l,r,tree[k].ls,val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) tree_insert(mid+<span class="number">1</span>,kr,l,r,tree[k].rs,val);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tree_insert(kl,mid,l,mid,tree[k].ls,val);</span><br><span class="line">        tree_insert(mid+<span class="number">1</span>,kr,mid+<span class="number">1</span>,r,tree[k].rs,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> kl,<span class="keyword">int</span> kr,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    LL res=tree[k].lazy*(r-l+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> mid=(kl+kr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(kl==l&amp;&amp;kr==r) <span class="keyword">return</span> res+tree[k].sum;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) res+=query(kl,mid,l,r,tree[k].ls);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) res+=query(mid+<span class="number">1</span>,kr,l,r,tree[k].rs);</span><br><span class="line">    <span class="keyword">else</span> res+=query(kl,mid,l,mid,tree[k].ls)+query(mid+<span class="number">1</span>,kr,mid+<span class="number">1</span>,r,tree[k].rs);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))&#123;</span><br><span class="line">        <span class="built_in">memset</span>(root,<span class="number">0</span>,<span class="keyword">sizeof</span>(root));</span><br><span class="line">        tree[<span class="number">0</span>].sum=tree[<span class="number">0</span>].lazy=tree[<span class="number">0</span>].ls=tree[<span class="number">0</span>].rs=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;ori[i]);</span><br><span class="line">            sum[i]=sum[i<span class="number">-1</span>]+ori[i];</span><br><span class="line">        &#125;</span><br><span class="line">        timestamp=tot=<span class="number">0</span>;</span><br><span class="line">        pre_build(++tot,<span class="number">1</span>,n);</span><br><span class="line">        root[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        LL c;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;ch);</span><br><span class="line">            <span class="keyword">while</span>(ch!=<span class="string">'C'</span>&amp;&amp;ch!=<span class="string">'H'</span>&amp;&amp;ch!=<span class="string">'Q'</span>&amp;&amp;ch!=<span class="string">'B'</span>)<span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;ch);</span><br><span class="line">            <span class="keyword">if</span>(ch==<span class="string">'C'</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">                ++timestamp;</span><br><span class="line">                root[timestamp]=root[timestamp<span class="number">-1</span>];</span><br><span class="line">                tree_insert(<span class="number">1</span>,n,a,b,root[timestamp],c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">'Q'</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">                LL res=query(<span class="number">1</span>,n,a,b,root[timestamp]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">'H'</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">                LL res=query(<span class="number">1</span>,n,a,b,root[c]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">'B'</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;timestamp);</span><br><span class="line">                root[timestamp+<span class="number">1</span>]==<span class="number">0</span>?:tot=root[timestamp+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;主席树的原理及使用&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#主席树的原理及使用&quot;&gt;&lt;/a&gt; 主席树的原理及使用&lt;/h1&gt;
&lt;h2 id=&quot;0前置知识&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#0前置
      
    
    </summary>
    
    
      <category term="ICPC" scheme="https://tlooper.github.io/tags/ICPC/"/>
    
  </entry>
  
  <entry>
    <title>sup-004 Docker环境搭建与开发入门</title>
    <link href="https://tlooper.github.io/sup-004/"/>
    <id>https://tlooper.github.io/sup-004/</id>
    <published>2019-07-19T03:49:25.000Z</published>
    <updated>2019-07-26T07:23:25.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker环境搭建与开发入门"><a class="markdownIt-Anchor" href="#docker环境搭建与开发入门"></a> Docker环境搭建与开发入门</h1><h2 id="0博客参考与引用"><a class="markdownIt-Anchor" href="#0博客参考与引用"></a> 0.博客参考与引用</h2><p><a href="https://www.cnblogs.com/ECJTUACM-873284962/p/9789130.html" target="_blank" rel="noopener">这可能是最为详细的Docker入门吐血总结</a></p><p><a href="https://docs.docker.com/" target="_blank" rel="noopener">Docker 官方文档</a></p><h2 id="1docker简介与架构"><a class="markdownIt-Anchor" href="#1docker简介与架构"></a> 1.Docker简介与架构</h2><p>容器：容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以<strong>分离的进程</strong>运行。<img src="/sup-004/1.png" alt="p1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;docker环境搭建与开发入门&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#docker环境搭建与开发入门&quot;&gt;&lt;/a&gt; Docker环境搭建与开发入门&lt;/h1&gt;
&lt;h2 id=&quot;0博客参考与引用&quot;&gt;&lt;a class=&quot;markdown
      
    
    </summary>
    
    
      <category term="search" scheme="https://tlooper.github.io/tags/search/"/>
    
  </entry>
  
  <entry>
    <title>sup-extra LCA+st表</title>
    <link href="https://tlooper.github.io/sup-extra-LCA/"/>
    <id>https://tlooper.github.io/sup-extra-LCA/</id>
    <published>2019-05-05T13:04:24.000Z</published>
    <updated>2019-05-12T05:16:14.266Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lcast表"><a class="markdownIt-Anchor" href="#lcast表"></a> LCA+st表</h1><h2 id="1-lca"><a class="markdownIt-Anchor" href="#1-lca"></a> 1. LCA</h2><p>​LCA，即最近公共祖先（Lowest Common Ancestor)，用于解决的问题：<strong>树上任意一对点间的距离</strong>。</p><p>​求解LCA常用的两种方法：</p><p><strong>1. 静态Tarjan方法</strong></p><p>​<strong>基本思想</strong>：毕竟是静态方法嘛，讲究的就是先把询问和树都存起来然后遍历树的时候就直接处理询问。时间复杂度是O(n+m),其中n为点数，m为询问数。</p><p>​<strong>具体操作</strong>：假设目前我们需要寻找点a、b的LCA，那么我们在DFS的时候利用并查集，在一个点的DFS return 时将该点的所有子结点都加到它的父节点里面。利用DFS一个子树遍历完才遍历第二个子树的特性，如果当a b 的LCA为c时，当你先遍历了点a,再遍历到b时，你会发现a的父节点已经被并查集更新为c了。此处附上他人的<a href="https://www.cnblogs.com/JVxie/p/4854719.html" target="_blank" rel="noopener">更详细的过程</a>。</p><p>​<strong>板子代码</strong>：由于不常用暂略。</p><p><strong>2.动态倍增方法</strong></p><p>​<strong>基本思想</strong>：说白了就是二进制嘛，只要我预先处理出树上每个节点的往上走1、 2、 4、……2<sup>n</sup>层的点，然后让询问的两个点都往上跳，直到深度相同，两点再同时往上跳，此时的点就是要求的公共祖先点了嘛。预处理时间复杂度O(nlog(n))，每次询问的时间复杂度是O(log(n))。</p><p>​<strong>具体操作</strong>：同样用DFS，遍历到每个点时，都处理出每个点往上走那么多层的距离。询问时再利用二进制让a b两点跳到同一深度，如果此时父节点不同则继续往上跳，直到父节点相同为止。</p><p>​<strong>板子代码节选</strong>：</p><p class="code-caption" data-lang="cpp" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line">LL dis[maxn],dep[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,dis;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; tree[maxn];</span><br><span class="line"><span class="keyword">int</span> par[maxn][maxm];<span class="comment">//最大为2^maxm的深度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_dfs</span><span class="params">(<span class="keyword">int</span> fa,<span class="keyword">int</span> u,<span class="keyword">int</span> depth,<span class="keyword">int</span> dist)</span></span>&#123;</span><br><span class="line">    dis[u]=dist;</span><br><span class="line">    dep[u]=depth;<span class="comment">//更新点u的深度和到根节点的距离</span></span><br><span class="line">    <span class="keyword">if</span>(u==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxm;i++)par[u][i]=u;<span class="comment">//定1为根节点，则往上跳多少都是自身</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        par[u][<span class="number">0</span>]=fa;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;maxm;i++)&#123;</span><br><span class="line">            par[u][i]=par[par[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];<span class="comment">//2^i层的节点=u往上跳2^i-1层的点再往上跳2^i-1层</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理完u之后再进行常规的DFS</span></span><br><span class="line">    <span class="keyword">int</span> len=tree[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=tree[u][i].to,d=tree[u][i].dis;</span><br><span class="line">        <span class="keyword">if</span>(v!=fa) pre_dfs(u,v,depth+<span class="number">1</span>,d+dist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">skip</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=maxm<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;level)&#123;<span class="comment">//二进制的思想</span></span><br><span class="line">            a=par[a][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[a]&lt;dep[b]) swap(a,b);<span class="comment">//保证a比较深</span></span><br><span class="line">    a=skip(a,dep[a]-dep[b]);</span><br><span class="line">    <span class="keyword">if</span>(a==b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=maxm<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//也是利用二进制思想从高位往低位逼近的思想</span></span><br><span class="line">        <span class="keyword">if</span>(par[a][i]!=par[b][i])&#123;</span><br><span class="line">            a=par[a][i];</span><br><span class="line">            b=par[b][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> par[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.LCA转化为RMQ问题</strong></p><p>​<strong>基本思想</strong>：与Tarjan求法的思想一致，当你从a遍历到b时经过的深度最小的点即为最近公共祖先。之所以能转化为RMQ，是将DFS时产生长度为2<em>n-1的欧拉序列~~（实际上就是每经过一个点就标一个号，不管是初次访问还是回退时，所以每个点访问两次）~~当做一个区间，记录每一个点的初次出现的编号first[i]，然后找first[a]到first[b]这段区间中</em>深度最浅的点。（<a href="https://blog.csdn.net/diogenes_/article/details/81412316" target="_blank" rel="noopener">参考博客</a>）</p><p>​<strong>具体操作及代码</strong>见st表部分</p><h2 id="2st表"><a class="markdownIt-Anchor" href="#2st表"></a> 2.st表</h2><p>​<strong>基本思想</strong>：st表与LCA动态倍增算法相似，均是采用的二进制思想，用st [ i ] [ j ]数组来存储 i 到 i+2<sup>j</sup>-1,共2<sup>j</sup>长度的区间上的最值问题。预处理时间复杂度为O（nlogn) 查询时间为 O(1)，并不支持在线修改。所以基本上就是用来求区间最值的。</p><p>​<strong>具体操作</strong>：由于是最值嘛，所以st[i ] [0 ]=i, st[ i ] [ j ]=max (st[ i ] [ j-1 ] , st[ i+ 2<sup>j-1</sup> ] [ j-1 ] ) ，算法也简单，只要记得预处理就完事了。</p><p>​<strong>用st表解决LCA问题的代码：</strong>（<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2586" target="_blank" rel="noopener">例题</a>）</p><p class="code-caption" data-lang="cpp" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">40004</span>,maxm=<span class="number">20</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    LL dis;</span><br><span class="line">    edge(<span class="keyword">int</span> _to,LL _dis)&#123;</span><br><span class="line">        to=_to;</span><br><span class="line">        dis=_dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">LL dis[maxn];</span><br><span class="line"><span class="keyword">int</span> dep[maxn],first[maxn],oula[maxn*<span class="number">2</span>],st[maxn*<span class="number">2</span>][maxm];</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; tree[maxn];</span><br><span class="line"><span class="keyword">int</span> coun,n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> fa,<span class="keyword">int</span> u,<span class="keyword">int</span> depth,<span class="keyword">int</span> dist)</span></span>&#123;</span><br><span class="line">    oula[coun++]=u;</span><br><span class="line">    <span class="keyword">if</span>(first[u]==<span class="number">0</span>) first[u]=coun<span class="number">-1</span>;</span><br><span class="line">    dep[u]=depth;</span><br><span class="line">    dis[u]=dist;</span><br><span class="line">    <span class="keyword">int</span> len=tree[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=tree[u][i].to,d=tree[u][i].dis;</span><br><span class="line">        <span class="keyword">if</span>(v!=fa) &#123;</span><br><span class="line">            dfs(u,v,depth+<span class="number">1</span>,dist+d);</span><br><span class="line">            oula[coun++]=u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> dep[a]&lt;dep[b]?a:b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)&#123;</span><br><span class="line">        st[i][<span class="number">0</span>]=oula[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;maxm;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;n*<span class="number">2</span>;i++)&#123;</span><br><span class="line">            st[i][j]=comp(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=first[a],r=first[b];</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) swap(l,r);</span><br><span class="line">    <span class="keyword">int</span> k=log2(r-l+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> comp(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"></span><br><span class="line">            LL c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            tree[a].push_back(edge(b,c));</span><br><span class="line">            tree[b].push_back(edge(a,c));</span><br><span class="line">        &#125;</span><br><span class="line">        coun=<span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        st_init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="keyword">int</span> fa=lca(a,b);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dis[a]+dis[b]<span class="number">-2</span>*dis[fa]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;lcast表&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lcast表&quot;&gt;&lt;/a&gt; LCA+st表&lt;/h1&gt;
&lt;h2 id=&quot;1-lca&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-lca&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="ICPC" scheme="https://tlooper.github.io/tags/ICPC/"/>
    
  </entry>
  
  <entry>
    <title>sup-003 微信小程序开发快速入门</title>
    <link href="https://tlooper.github.io/sup-003/"/>
    <id>https://tlooper.github.io/sup-003/</id>
    <published>2019-03-09T04:26:58.000Z</published>
    <updated>2019-03-09T10:35:22.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微信小程序开发快速入门持续更新"><a class="markdownIt-Anchor" href="#微信小程序开发快速入门持续更新"></a> 微信小程序开发快速入门（持续更新）</h1><p>​<strong>本教程基于微信开发者工具所提供的指南归纳提炼重点而成，教程编写日期为2019年3月9日，如果有后续更新导致的版本差异，一切以<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/MINA.html" target="_blank" rel="noopener">官方文档</a>为主</strong></p><h2 id="微信小程序基本框架"><a class="markdownIt-Anchor" href="#微信小程序基本框架"></a> 微信小程序基本框架</h2><ol><li><p>微信小程序的开发逻辑与网页开发逻辑一致，分为前端（客户端）与后端（服务器端）两部分，为了弱化后端概念，微信提供云开发组件，<strong>云开发功能提供数据库管理、云函数使用的功能，简单来说就是实现对用户数据的存储与处理</strong>，<em>具体介绍参考后面的云开发指南章节</em></p></li><li><p>微信小程序的前端逻辑：</p></li></ol><p class="code-caption" data-lang="mermaid" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">a1[前端]--&gt;a2&#123;逻辑层&#125;</span><br><span class="line">a1--&gt;a3&#123;视图层&#125;</span><br><span class="line"></span><br><span class="line">a2---sub1[JavaScript]</span><br><span class="line">a2---sub4[json]</span><br><span class="line">a3---sub2[wxml]</span><br><span class="line">a3---sub3[wxss]</span><br></pre></td></tr></table></figure><ol start="3"><li>前端文件间的关联：（设页面名为page）</li></ol><p class="code-caption" data-lang="mermaid" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">a[app.js]--&quot;定义app()用以页面JS调用&quot;--&gt;a2[page.js]</span><br><span class="line">b[app.json]--&quot;决定小程序的整体布局，部分细节可由页面json文件微调&quot;--&gt;b2[page.json]</span><br><span class="line">subgraph pages</span><br><span class="line">wxml[page.wxml]--&quot;调用JS定义的数据与方法&quot;---a2</span><br><span class="line">wxss[page.wxss]--&quot;决定样式&quot;---wxml</span><br><span class="line">wxs[page.wxs或&lt;wxs&gt;]--&quot;前端的简易脚本&quot;--&gt;wxml</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ol start="4"><li><p>WXS与js区别与具体应用场景：<br>wxs是为视图层服务的脚本，主要用于诸如在前端进行简单运算或者调用一些基础类库的功能，不能响应事件。<br>js虽然会负责提供初始数据，更多的功能是处理事件，诸如页面打开、挂起、关闭、分享、用户下拉刷新、组件的调用等，起到调用API具体处理问题、与后端交互的功能。</p></li><li><p>页面生命周期：<br>onLoad-&gt;(onShow-&gt;onHide)<em>可能存在多个</em>-&gt;onUnload。具体生命周期涉及逻辑层与视图层多次互动，详细内容参见<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" target="_blank" rel="noopener">官方文档</a></p></li><li><p><a href="https://developers.weixin.qq.com/miniprogram/design/" target="_blank" rel="noopener">页面设计指南</a></p></li></ol><h2 id="云开发指南"><a class="markdownIt-Anchor" href="#云开发指南"></a> 云开发指南</h2><ol><li>数据库：可对不同数据类型进行权限控制，限定用户只能修改自己的数据，但可以读取他人数据。读取隐私数据操作需使用云函数来保证安全性，普通操作可在用户端实现。数据库的查找、访问均由API实现。</li><li>存储：可将云端内容存储到用户本地，诸如用来更新历史记录等操作，可在用户端与管理端实现操作，对文件的操作均基于上传后得到的文件ID，并且文件可设置权限。</li><li>云函数：运行环境为node.js ，使用云函数时可以无视多数权限以操作数据库与存储。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;微信小程序开发快速入门持续更新&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#微信小程序开发快速入门持续更新&quot;&gt;&lt;/a&gt; 微信小程序开发快速入门（持续更新）&lt;/h1&gt;
&lt;p&gt;​	&lt;strong&gt;本教程基于微信开发者工具所提供的指南归纳提
      
    
    </summary>
    
    
      <category term="reference" scheme="https://tlooper.github.io/tags/reference/"/>
    
  </entry>
  
  <entry>
    <title>sup-extra 网络流及其进阶</title>
    <link href="https://tlooper.github.io/sup-extra-%E7%BD%91%E7%BB%9C%E6%B5%81%E5%8F%8A%E5%85%B6%E8%BF%9B%E9%98%B6/"/>
    <id>https://tlooper.github.io/sup-extra-网络流及其进阶/</id>
    <published>2019-01-28T06:35:53.000Z</published>
    <updated>2019-07-24T02:13:31.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络流及其进阶的部分感想"><a class="markdownIt-Anchor" href="#网络流及其进阶的部分感想"></a> 网络流及其进阶的部分感想</h1><hr><p>​　　网络流：将网络看成一堆管道，其中一个点是入水口，一个点是出水口，这样的一种思想。同时也有诸多变形。</p><p>​　　具有的性质：除了起点与终点之外，每个点的入流量和出流量是相等的。</p><p>###可以解决的问题：</p><ol><li><p>最大流问题：最大的情况下能有多少流量。</p><p>具体算法：Dinic算法：</p><p>1、初始化网络和网络流：对每条有向边构造一条带正权值的边和一条权值为0的反向边。建图也可以常规用vector 建。</p><p>2、构造剩余网络和层次网络，若汇点不在层次网络中则算法结束：利用BFS来给每个点标层数，如果汇点没有层数（-1)就说明汇点不在层次网络中了。</p><p>3、在层次图G_L内用一次DFS过程进行增广，每次增广完毕，在层次网络中要去掉因改进流量而导致饱和的弧，DFS执行完毕则该阶段增广完毕：每次去掉的必定是DFS经过的一条链上最小的权值，利用DFS回退来实现对路径上的修改。</p><p>4、转步骤2。</p><p><em>时间复杂度：O(V^2·E)</em></p><p>模板题：<a href="https://vjudge.net/problem/10499/origin" target="_blank" rel="noopener">POJ - 1273 </a></p><p>AC代码：</p></li></ol><p class="code-caption" data-lang="cpp" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">202</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,val,nxt;</span><br><span class="line">&#125;e[maxn*<span class="number">2</span>] ;</span><br><span class="line"><span class="keyword">int</span> deep[maxn],son[maxn],n,m,coun,s,t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[coun].to=v;e[coun].val=c,e[coun].nxt=son[u];</span><br><span class="line">    son[u]=coun++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(deep,<span class="number">-1</span>,<span class="keyword">sizeof</span>(deep));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    deep[s]=<span class="number">0</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=son[u];i!=<span class="number">-1</span>;i=e[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(deep[v]==<span class="number">-1</span>&amp;&amp;e[i].val&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                deep[v]=deep[u]+<span class="number">1</span>;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (deep[t]!=<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t)</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=son[u];i!=<span class="number">-1</span>;i=e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(e[i].val&amp;&amp;deep[u]+<span class="number">1</span>==deep[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=dfs(e[i].to,min(val,e[i].val));</span><br><span class="line">            res+=tmp;</span><br><span class="line">            val-=tmp;</span><br><span class="line">            e[i].val-=tmp;</span><br><span class="line">            e[i^<span class="number">1</span>].val+=tmp;</span><br><span class="line">            <span class="keyword">if</span>(val==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs())</span><br><span class="line">    &#123;</span><br><span class="line">        res+=dfs(s,INF);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,v,c;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        s=<span class="number">1</span>,t=m;</span><br><span class="line">        <span class="built_in">memset</span>(son,<span class="number">-1</span>,<span class="keyword">sizeof</span>(son));</span><br><span class="line">        coun=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;c);</span><br><span class="line">            addedge(u,v,c);</span><br><span class="line">            addedge(v,u,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;e[i].nxt&lt;&lt;' '&lt;&lt;e[i].to&lt;&lt;' '&lt;&lt;e[i].val&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,maxflow());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络流及其进阶的部分感想&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#网络流及其进阶的部分感想&quot;&gt;&lt;/a&gt; 网络流及其进阶的部分感想&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;​	　　网络流：将网络看成一堆管道，其中一个点是入水口，一个点是出水口，这
      
    
    </summary>
    
    
      <category term="ICPC" scheme="https://tlooper.github.io/tags/ICPC/"/>
    
  </entry>
  
  <entry>
    <title>sup-extra HYSBZ-2809 dispatching 左偏树</title>
    <link href="https://tlooper.github.io/sup-extra-Splay%E6%A8%A1%E6%9D%BF/"/>
    <id>https://tlooper.github.io/sup-extra-Splay模板/</id>
    <published>2019-01-25T07:43:10.000Z</published>
    <updated>2019-01-25T09:45:32.991Z</updated>
    
    <content type="html"><![CDATA[<p>#splay 模板</p><p>Splay Tree,中文称之为伸展树，即二叉查找树的改进。伸展树中每个节点x满足：左子树中每个元素都小于x,右子树中每个元素都大于x，<s>说白了就是二叉树的操作嘛</s> 并且可以自我调整进行伸展操作。</p><p>伸展操作即<strong>将一个点x经过旋转变成根节点</strong>的操作。左旋/右旋操作就是把根节点的左/右儿子与根节点的位子变换（当然要保持树的结构，不是直接换两个数的变换）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#splay 模板&lt;/p&gt;
&lt;p&gt;Splay Tree,中文称之为伸展树，即二叉查找树的改进。伸展树中每个节点x满足：左子树中每个元素都小于x,右子树中每个元素都大于x，&lt;s&gt;说白了就是二叉树的操作嘛&lt;/s&gt; 并且可以自我调整进行伸展操作。&lt;/p&gt;
&lt;p&gt;伸展操作即&lt;str
      
    
    </summary>
    
    
      <category term="ICPC" scheme="https://tlooper.github.io/tags/ICPC/"/>
    
  </entry>
  
  <entry>
    <title>sup-extra HDU-4609 3-idiots  FFT</title>
    <link href="https://tlooper.github.io/HDU-4609%203-idiots%20FFT/"/>
    <id>https://tlooper.github.io/HDU-4609 3-idiots FFT/</id>
    <published>2019-01-24T06:57:08.000Z</published>
    <updated>2019-01-24T07:27:10.902Z</updated>
    
    <content type="html"><![CDATA[<p>#<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4609" target="_blank" rel="noopener">HDU-4609</a> 3-idiots FFT</p><p>题意就是在一组数中找三个数，计算能够组成三角形的概率是多少。这里就体现了FFT的用法其二，计算a+b的可能情况时转换成多项式乘法的运用。</p><p>由于x^a * x^b = x^(a+b),所以我们只要将数的值视作幂值，数的个数视作系数，就能将加法运算变为乘法运算了。这就是解这题的核心部分了。另一个难点在于如何处理构成三角形的条件<em>a+b&gt;c</em>的呢？我们需要利用容斥原理把不能构成的情况和c不是最大的数的情况列出来然后减去。不能构成的情况有：</p><ol><li><p>a+b时同一个数加了两次。解决：遍历数组减去num[a[i]+a[i]]</p></li><li><p>a+b与b+a重复统计。解决：减掉了上面的情况后将num/=2;</p></li><li><p>a+b后与a比较。此时多加了n-1，在结果上减掉。</p></li><li><p>a+b 中a&gt;c,b&lt;c. 当c为第i个数时，此时多加了（n-i-1)*i个数</p></li><li><p>a+b 中a&gt;c,b&gt;c. 当c为第i个数时，此时多加了 (n-i-1)*(n-i-2)/2个数</p><p>所以只要减掉这些情况就能得到正确的值了。</p><p><s>除此之外还遇到了比如FFT的最大数目不对啊，要用long long 啊，遍历的时候越界啊之类的智障错误……</s></p></li></ol><p class="code-caption" data-lang="cpp" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxl (1&lt;&lt;17)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.141592653589793238462643383</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> re,im;</span><br><span class="line">    <span class="keyword">complex</span> (<span class="keyword">double</span> r=<span class="number">0.0</span>,<span class="keyword">double</span> i=<span class="number">0.0</span>)&#123;re=r;im=i;&#125;</span><br><span class="line"></span><br><span class="line">&#125;a[maxl*<span class="number">2</span>],w[<span class="number">2</span>][maxl*<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">complex</span> <span class="keyword">operator</span> +(<span class="keyword">const</span> <span class="keyword">complex</span>&amp;x,<span class="keyword">const</span> <span class="keyword">complex</span>&amp;y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">complex</span>(x.re+y.re,x.im+y.im);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">complex</span> <span class="keyword">operator</span> -(<span class="keyword">const</span> <span class="keyword">complex</span>&amp;x,<span class="keyword">const</span> <span class="keyword">complex</span>&amp;y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">complex</span>(x.re-y.re,x.im-y.im);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">complex</span> <span class="keyword">operator</span> *(<span class="keyword">const</span> <span class="keyword">complex</span>&amp;x,<span class="keyword">const</span> <span class="keyword">complex</span>&amp;y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">complex</span>(x.re*y.re-x.im*y.im,x.im*y.re+x.re*y.im);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,m,rev[maxl*<span class="number">2</span>],sum[maxl*<span class="number">2</span>],ori[maxl*<span class="number">2</span>],num[maxl*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//calculate reverse</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> coun=i,tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j&lt;&lt;=<span class="number">1</span>,coun&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            tmp|=(coun&amp;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rev[i]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        w[<span class="number">0</span>][i]=w[<span class="number">1</span>][i]=<span class="keyword">complex</span>(<span class="built_in">cos</span>(<span class="number">2</span>*pi*i/n),<span class="built_in">sin</span>(<span class="number">2</span>*pi*i/n));</span><br><span class="line">        w[<span class="number">1</span>][i].im=-w[<span class="number">0</span>][i].im;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">complex</span> *a,<span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">complex</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i])swap(a[i],a[rev[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,t=n/(i&lt;&lt;<span class="number">1</span>);j&lt;n;j+=i&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>,l=<span class="number">0</span>;k&lt;i;k++,l+=t)</span><br><span class="line">        &#123;</span><br><span class="line">            x=w[order][l]*a[j+k+i];</span><br><span class="line">            y=a[j+k];</span><br><span class="line">            a[j+k]=y+x;</span><br><span class="line">            a[j+k+i]=y-x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(order)<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i].re/=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;m);</span><br><span class="line">        <span class="keyword">int</span> most=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;ori[i]);</span><br><span class="line">            a[ori[i]].re++;</span><br><span class="line">            <span class="keyword">if</span>(most&lt;ori[i])</span><br><span class="line">                most=ori[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(n=<span class="number">1</span>;n&lt;=most;n&lt;&lt;=<span class="number">1</span>);n&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        init();</span><br><span class="line">        FFT(a,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i]=a[i]*a[i];</span><br><span class="line">        FFT(a,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            num[i]=(<span class="keyword">long</span> <span class="keyword">long</span>)(a[i].re+<span class="number">0.5</span>);</span><br><span class="line">            <span class="comment">//cout&lt;&lt;i&lt;&lt;' '&lt;&lt;num[i]&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">            num[ori[i]+ori[i]]--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            num[i]/=<span class="number">2</span>;</span><br><span class="line">        sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[i]=sum[i<span class="number">-1</span>]+num[i];<span class="comment">//前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;i&lt;&lt;' '&lt;&lt;num[i]&lt;&lt;' '&lt;&lt;sum[i]&lt;&lt;endl;*/</span></span><br><span class="line">        sort(ori,ori+m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=sum[n<span class="number">-1</span>]-sum[ori[i]];<span class="comment">//总和</span></span><br><span class="line">            res-=(<span class="keyword">long</span> <span class="keyword">long</span>)(m<span class="number">-1</span>-i)*i;<span class="comment">//一大一小</span></span><br><span class="line">            res-=(<span class="keyword">long</span> <span class="keyword">long</span>)(m<span class="number">-1</span>-i)*(m<span class="number">-2</span>-i)/<span class="number">2</span>;<span class="comment">//两个大</span></span><br><span class="line">            res-=m<span class="number">-1</span>;<span class="comment">//自身</span></span><br><span class="line">            <span class="comment">//cout&lt;&lt;sum[n-1]-sum[ori[i]]&lt;&lt;' '&lt;&lt;(m-1-i)*i&lt;&lt;(m-1-i)*(m-2-i)/2&lt;&lt;m-1&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tot=m*(m<span class="number">-1</span>)*(m<span class="number">-2</span>)/<span class="number">6</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.7lf\n"</span>,(<span class="keyword">double</span>)(res*<span class="number">1.0</span>/tot));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            a[i].re=a[i].im=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=4609&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HDU-4609&lt;/a&gt; 3-idiots FFT&lt;/p&gt;
&lt;p&gt;题意就是在一组数中找三个数，计
      
    
    </summary>
    
    
      <category term="ICPC" scheme="https://tlooper.github.io/tags/ICPC/"/>
    
  </entry>
  
  <entry>
    <title>sup-extra HDU-1402 A*B Problem Plus  FFT模板题</title>
    <link href="https://tlooper.github.io/HDU-1402%20A%20%20B%20Problem%20Plus%20%20FFT/"/>
    <id>https://tlooper.github.io/HDU-1402 A  B Problem Plus  FFT/</id>
    <published>2019-01-22T16:43:31.000Z</published>
    <updated>2019-01-24T06:55:25.794Z</updated>
    
    <content type="html"><![CDATA[<p>#<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1402" target="_blank" rel="noopener">HDU-1402</a> A*B Problem Plus  FFT模板题</p><hr><p>题目就是一个大数乘法，由于位数长度达到了50000级别所以不能用常规写法，需要使用FFT解题。<br>　　那么首先需要知道的问题是，FFT是什么，是拿来干什么的？</p><blockquote><p><strong>FFT，即为快速傅氏变换，是离散傅氏变换的快速算法，它是根据离散傅氏变换的奇、偶、虚、实等特性，对离散傅立叶变换的算法进行改进获得的。</strong></p></blockquote><p>看上去很复杂，但实际上我们使用FFT是要解决的就是多项式乘法。多项式的表示有两种：</p><p>1.系数表示法，形如f(x)=a<sub>0</sub>+a<sub>1</sub>X+a<sub>2</sub>X<sup>2</sup>+…a<sub>n</sub>X<sup>n</sup>，其中告诉你所有的a的值，就是系数表示法</p><p>2.点值表示法，利用(x<sub>0</sub>,y<sub>0</sub>) (x<sub>1</sub>,y<sub>1</sub>)…(X<sub>n</sub>,y<sub>n</sub>)这么n个点来约束的n次多项式，你知道所有的x,y的值，就是点值表示法</p><p>如果F(x)=f(x)*g(x) 那么F(x<sub>0</sub>)=f(x<sub>0</sub>) * g(x<sub>0</sub>)  这个结论看上去就很自然。所以对于n+1个点我们都可以通过算出来的f(x) g(x)求出相应的F(x)。也就是说我们只要知道f(x) g(x)的点值表示法，算出n+1个点，就能得到乘法乘出来的F(x) 函数的点值表示法。</p><p>所以为了求出点值表示法的函数，我们就需要先找n+1个x的值出来。为了便于计算x<sup>k</sup> 我们选取的就是复数平面上单位元的点，这样k次方得到的就是1了。FFT实现的就是<strong>把系数表示法变成点值表示法，把点值表示法变成系数表示法</strong>。</p><p>至于FFT可以变成2个DFT啊、求和的分治算法为了防止爆栈而变成下标反向的循环运算啊、IDFT和DFT之间只差一个1/n这种细节就不用理解了，还有诸如“你把一个函数扩展到了复数平面上后结果要是有虚部怎么办的问题”啊，我只能说理论上两个纯实部的函数就算代进虚部的函数值生成的新函数也不会产生有虚部的变量，至于为什么只能说是一些奇妙的性质了，<strong>总之明白了FFT是把什么东西变成了什么之后你甚至不用知道原理，拿着板子用就行。</strong></p><p>附上代码：</p><p class="code-caption" data-lang="cpp" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxl (1&lt;&lt;16)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.141592653589793238462643383</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> re,im;</span><br><span class="line">    <span class="keyword">complex</span> (<span class="keyword">double</span> r=<span class="number">0.0</span>,<span class="keyword">double</span> i=<span class="number">0.0</span>)&#123;re=r;im=i;&#125;</span><br><span class="line"></span><br><span class="line">&#125;a[maxl*<span class="number">2</span>],b[maxl*<span class="number">2</span>],w[<span class="number">2</span>][maxl*<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">complex</span> <span class="keyword">operator</span> +(<span class="keyword">const</span> <span class="keyword">complex</span>&amp;x,<span class="keyword">const</span> <span class="keyword">complex</span>&amp;y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">complex</span>(x.re+y.re,x.im+y.im);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">complex</span> <span class="keyword">operator</span> -(<span class="keyword">const</span> <span class="keyword">complex</span>&amp;x,<span class="keyword">const</span> <span class="keyword">complex</span>&amp;y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">complex</span>(x.re-y.re,x.im-y.im);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">complex</span> <span class="keyword">operator</span> *(<span class="keyword">const</span> <span class="keyword">complex</span>&amp;x,<span class="keyword">const</span> <span class="keyword">complex</span>&amp;y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">complex</span>(x.re*y.re-x.im*y.im,x.im*y.re+x.re*y.im);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">int</span> n,na,nb,rev[maxl*<span class="number">2</span>],res[maxl*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> oria[maxl],orib[maxl];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//calculate reverse</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> coun=i,tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j&lt;&lt;=<span class="number">1</span>,coun&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            tmp|=(coun&amp;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        rev[i]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        w[<span class="number">0</span>][i]=w[<span class="number">1</span>][i]=<span class="keyword">complex</span>(<span class="built_in">cos</span>(<span class="number">2</span>*pi*i/n),<span class="built_in">sin</span>(<span class="number">2</span>*pi*i/n));</span><br><span class="line">        w[<span class="number">1</span>][i].im=-w[<span class="number">0</span>][i].im;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">complex</span> *a,<span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">complex</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i])swap(a[i],a[rev[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,t=n/(i&lt;&lt;<span class="number">1</span>);j&lt;n;j+=i&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>,l=<span class="number">0</span>;k&lt;i;k++,l+=t)</span><br><span class="line">        &#123;</span><br><span class="line">            x=w[order][l]*a[j+k+i];</span><br><span class="line">            y=a[j+k];</span><br><span class="line">            a[j+k]=y+x;</span><br><span class="line">            a[j+k+i]=y-x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(order)<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i].re/=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,oria,orib))</span><br><span class="line">    &#123;</span><br><span class="line">        na=nb=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(oria[na]!=<span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a[na].re=oria[na]-<span class="string">'0'</span>;</span><br><span class="line">            a[na].im=<span class="number">0</span>;</span><br><span class="line">            na++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(orib[nb]!=<span class="string">'\0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b[nb].re=orib[nb]-<span class="string">'0'</span>;</span><br><span class="line">            b[nb].im=<span class="number">0</span>;</span><br><span class="line">            nb++;</span><br><span class="line">        &#125;</span><br><span class="line">        n=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&lt;na||n&lt;nb) n&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        n&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;"n:"&lt;&lt;n&lt;&lt;endl;</span></span><br><span class="line">        init();</span><br><span class="line">        <span class="comment">//cout&lt;&lt;"done"&lt;&lt;endl;</span></span><br><span class="line">        FFT(a,<span class="number">0</span>);</span><br><span class="line">        FFT(b,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) a[i]=a[i]*b[i];</span><br><span class="line">        FFT(a,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(res,<span class="number">0</span>,<span class="keyword">sizeof</span>(res));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            res[i]=<span class="keyword">int</span>(a[i].re+<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i<span class="number">-1</span>]+=res[i]/<span class="number">10</span>;</span><br><span class="line">            res[i]%=<span class="number">10</span>;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;res[i];</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> resn=na+nb<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;resn;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(;i&lt;resn;i++)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d"</span>,res[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==resn<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i].re=a[i].im=b[i].re=b[i].im=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="comment">            printf("%lf%lf\n",a[i].re,a[i].im);*/</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1402&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HDU-1402&lt;/a&gt; A*B Problem Plus  FFT模板题&lt;/p&gt;
&lt;hr&gt;
&lt;
      
    
    </summary>
    
    
      <category term="ICPC" scheme="https://tlooper.github.io/tags/ICPC/"/>
    
  </entry>
  
  <entry>
    <title>sup-extra CodeForce-1009E Dominant Indices 启发式合并</title>
    <link href="https://tlooper.github.io/CodeForce-1009F%20Dominant%20Indices%20%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    <id>https://tlooper.github.io/CodeForce-1009F Dominant Indices 启发式合并/</id>
    <published>2019-01-21T04:00:00.000Z</published>
    <updated>2019-01-22T16:36:41.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="codeforce-1009f"><a class="markdownIt-Anchor" href="#codeforce-1009f"></a> <a href="http://codeforces.com/problemset/problem/1009/F" target="_blank" rel="noopener">CodeForce-1009F</a> Dominant Indices 启发式合并</h1><hr><p><s>写这个题的时候至少进行了一亿次心理博弈……</s></p><p>题意大致为：对以节点x为根形成的子树，找到节点最多的层数，要是有多个数值相同就取最小的。</p><p>虽然看得出来是启发式合并解法，但是写的时候对于到底要怎么更新存储的最大值和结果一直没想明白……一开始写的是在求完所有的点之后遍历一遍去找最大的值，但是发现当树过长的时候时间复杂度是O(N!）……翻了很多博客都是寻找重儿子后进行一次交换，保留重儿子的结果再进行加，于是我开始思考我能不能在 每次遇到比我的层数多的子树时，交换子树统计的每层点的个数，同时拿过来子树的最大值呢。</p><p>我原本的想法：</p><p>要是我现在的最大层为a1,交换后成了一个比它小的b1，然后加的时候没遇到a1这一层那最大值不就错了嘛。</p><p>然后发现既然能进行交换那进行合并的时候肯定会更新a1这一层的值……因为交换了之后还要把原本的各层加回去……</p><p>稍微更改一下思路就过了。</p><p class="code-caption" data-lang="cpp" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxl 1000006</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,res[maxl],most[maxl];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cal[maxl];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[maxl];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> depth,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cal[s][depth]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tree[s].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=tree[s][i];</span><br><span class="line">        <span class="keyword">if</span>(v==e) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v,depth+<span class="number">1</span>,s);</span><br><span class="line">        <span class="keyword">if</span>(cal[s].size()&lt;cal[v].size())</span><br><span class="line">        &#123;</span><br><span class="line">            swap(cal[s],cal[v]);</span><br><span class="line">            most[s]=most[v];</span><br><span class="line">            res[s]=res[v]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it=cal[v].begin();it!=cal[v].end();it++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=it-&gt;first;</span><br><span class="line">            cal[s][tmp]+=it-&gt;second;</span><br><span class="line">            <span class="keyword">if</span>(cal[s][tmp]&gt;most[s])</span><br><span class="line">            &#123;</span><br><span class="line">                res[s]=tmp-depth;</span><br><span class="line">                most[s]=cal[s][tmp];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cal[s][tmp]==most[s]&amp;&amp;res[s]&gt;(tmp-depth))</span><br><span class="line">                res[s]=tmp-depth;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">memset</span>(res,<span class="number">0</span>,<span class="keyword">sizeof</span>(res));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            most[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tree[i].clear();</span><br><span class="line">            cal[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">            tree[a].push_back(b);</span><br><span class="line">            tree[b].push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res[i]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;codeforce-1009f&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#codeforce-1009f&quot;&gt;&lt;/a&gt; &lt;a href=&quot;http://codeforces.com/problemset/problem/1009/F&quot;
      
    
    </summary>
    
    
      <category term="ICPC" scheme="https://tlooper.github.io/tags/ICPC/"/>
    
  </entry>
  
  <entry>
    <title>sup-extra CodeForces-600E  Lomsat gelral 启发式合并</title>
    <link href="https://tlooper.github.io/CodeForces%20600E%20%20Lomsat%20gelral%20%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
    <id>https://tlooper.github.io/CodeForces 600E  Lomsat gelral 启发式合并/</id>
    <published>2019-01-20T04:00:00.000Z</published>
    <updated>2019-01-22T16:42:24.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="codeforces-600e"><a class="markdownIt-Anchor" href="#codeforces-600e"></a> <a href="http://codeforces.com/problemset/problem/600/E" target="_blank" rel="noopener">CodeForces-600E</a>  Lomsat gelral 启发式合并</h1><hr><p>题意就是将一棵树的节点涂色，数目最多的颜色就是主导色，然后要求输出每一个点的主导色，如果有多个主导色就输出主导色的和。</p><p>解法参考了他人代码，具体思路即首先存储每个子树的颜色，然后再按照颜色出现次数维护sum，再存储最大次数的sum值。由于是树所以遍历回去之后不用考虑子树的状态，可以放心地调换color和sum。调换之后就能保证是将少的一组值合并到多的一组值里面去，即启发式合并的思想。</p><p class="code-caption" data-lang="cpp" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxl 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; color[maxl];</span><br><span class="line"><span class="comment">//color[x][y]:x= vertex number,y=color,val=color-sum;</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span> &gt;sum[maxl];</span><br><span class="line"><span class="comment">//sum[x][y]:x=vertex number,y=color-sum,val=res;</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[maxl];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res[maxl];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tree[s].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=tree[s][i];</span><br><span class="line">        <span class="keyword">if</span>(v==e) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v,s);</span><br><span class="line">        <span class="keyword">if</span>(color[s].size()&lt;color[v].size())</span><br><span class="line">        &#123;</span><br><span class="line">            swap(color[s],color[v]);</span><br><span class="line">            swap(sum[s],sum[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it=color[v].begin();it!=color[v].end();it++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[s][color[s][it-&gt;first]]-=it-&gt;first;<span class="comment">//sub color</span></span><br><span class="line">            color[s][it-&gt;first]+=it-&gt;second;<span class="comment">//change color-sum</span></span><br><span class="line">            sum[s][color[s][it-&gt;first]]+=it-&gt;first;<span class="comment">//add color</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res[s]=sum[s].rbegin()-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tree[i].clear();</span><br><span class="line">            color[i].clear();</span><br><span class="line">            sum[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c);</span><br><span class="line">            color[i][c]=<span class="number">1</span>;</span><br><span class="line">            sum[i][<span class="number">1</span>]=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">            tree[a].push_back(b);</span><br><span class="line">            tree[b].push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld "</span>,res[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res[n]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;codeforces-600e&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#codeforces-600e&quot;&gt;&lt;/a&gt; &lt;a href=&quot;http://codeforces.com/problemset/problem/600/E&quot; 
      
    
    </summary>
    
    
      <category term="ICPC" scheme="https://tlooper.github.io/tags/ICPC/"/>
    
  </entry>
  
  <entry>
    <title>sup-extra HDU-1512 Monkey King 左偏树</title>
    <link href="https://tlooper.github.io/HDU-1512%20Monkey%20King%20%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
    <id>https://tlooper.github.io/HDU-1512 Monkey King 左偏树/</id>
    <published>2019-01-19T07:00:00.000Z</published>
    <updated>2019-01-22T16:41:03.035Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hdu-1512"><a class="markdownIt-Anchor" href="#hdu-1512"></a> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1512" target="_blank" rel="noopener">HDU-1512</a> Monkey King 左偏树</h1><hr><p>题意是每次有两只猴子要battle，但是猴子battle的时候会叫自己认识的攻击力最高的猴子，并且battle结束后参加battle的猴子攻击力减半。</p><p>可以看出来这题就是要你维护两个优先队列，每次battle时弹出攻击力最高的，然后将攻击力减半再重新合并成一个新的队列。为了支持合并操作选用左偏树来实现。唯一需要注意的问题就是要记得更新你询问的节点的左偏树的根节点。<s>另外之前因为没有使用memset导致MLE，意义不明</s></p><p class="code-caption" data-lang="cpp" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxl 100003</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> root[maxl],lef[maxl],rig[maxl],val[maxl],dist[maxl];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> k)</span><span class="comment">//寻找目前的左偏树根节点的同时更新沿途的节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root[k]==k) <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> root[k]=findroot(root[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ltree_merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//左偏树合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>||y==<span class="number">0</span>) <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">if</span>(val[x]&lt;val[y]) swap(x,y);</span><br><span class="line">    rig[x]=ltree_merge(rig[x],y);</span><br><span class="line">    root[rig[x]]=x;</span><br><span class="line">    <span class="keyword">if</span>(dist[rig[x]]&gt;dist[lef[x]])</span><br><span class="line">        swap(rig[x],lef[x]);</span><br><span class="line">    <span class="keyword">if</span>(rig[x]==<span class="number">0</span>)</span><br><span class="line">        dist[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> dist[x]=dist[rig[x]]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ltree_pop</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//左偏树删除根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l1=lef[a],l2=lef[b],r1=rig[a],r2=rig[b];</span><br><span class="line">    root[l1]=l1;root[l2]=l2;root[r1]=r1;root[r2]=r2;</span><br><span class="line">    lef[a]=rig[a]=lef[b]=rig[b]=dist[a]=dist[b]=<span class="number">0</span>;</span><br><span class="line">    val[a]/=<span class="number">2</span>;val[b]/=<span class="number">2</span>;</span><br><span class="line">    a=ltree_merge(a,b);</span><br><span class="line">    b=ltree_merge(l1,r1);</span><br><span class="line">    a=ltree_merge(a,b);</span><br><span class="line">    b=ltree_merge(l2,r2);</span><br><span class="line">    <span class="keyword">return</span> ltree_merge(a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(root,<span class="number">0</span>,<span class="keyword">sizeof</span>(root));</span><br><span class="line">        <span class="built_in">memset</span>(lef,<span class="number">0</span>,<span class="keyword">sizeof</span>(lef));</span><br><span class="line">        <span class="built_in">memset</span>(rig,<span class="number">0</span>,<span class="keyword">sizeof</span>(rig));</span><br><span class="line">        <span class="built_in">memset</span>(dist,<span class="number">0</span>,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val[i]);</span><br><span class="line">        root[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid1,mid2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;mid1,&amp;mid2);</span><br><span class="line">        findroot(mid1);</span><br><span class="line">        findroot(mid2);</span><br><span class="line">        <span class="keyword">if</span>(root[mid1]==root[mid2])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res;</span><br><span class="line">            res=ltree_pop(root[mid1],root[mid2]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,val[res]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hdu-1512&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hdu-1512&quot;&gt;&lt;/a&gt; &lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1512&quot; target=&quot;_blank
      
    
    </summary>
    
    
      <category term="ICPC" scheme="https://tlooper.github.io/tags/ICPC/"/>
    
  </entry>
  
  <entry>
    <title>sup-extra HYSBZ-2809 dispatching 左偏树</title>
    <link href="https://tlooper.github.io/HYSBZ-2809%20dispatching%20%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
    <id>https://tlooper.github.io/HYSBZ-2809 dispatching 左偏树/</id>
    <published>2019-01-19T04:00:00.000Z</published>
    <updated>2019-03-29T15:57:57.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hysbz-2809"><a class="markdownIt-Anchor" href="#hysbz-2809"></a> <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2809" target="_blank" rel="noopener">HYSBZ-2809</a> dispatching 左偏树</h1><p>题意就是要找一棵子树满足薪水和小于总预算的同时，节点数*子树根的领导力要最大。</p><p>解题的思路就是对树的每个节点都存储它的薪水和，如果超出了总预算就弹出最大的点。同时因为是DFS，所以回到高层之后就不用管底层的节点的状态了。同时为了能弹出最大的点，不能只存储薪水和，应当保留所有的薪水值，但是使用优先队列又不能快速合并两个优先队列，所以考虑使用可并堆左偏树。</p><p>至于什么是左偏树…… <s>就是左倾的树(迫真)</s> 总之只要会用板子就行了。</p><p class="code-caption" data-lang="cpp" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxl 1000006</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[maxl];</span><br><span class="line"><span class="keyword">int</span> val[<span class="number">1000006</span>],lead[<span class="number">1000006</span>];</span><br><span class="line"><span class="keyword">int</span> lef[maxl],rig[maxl],dist[maxl],root[maxl];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[maxl],coun[maxl];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ltree_merge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//左偏树的合并操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>||b==<span class="number">0</span>) <span class="keyword">return</span> a+b;</span><br><span class="line">    <span class="keyword">if</span>(val[a]&lt;val[b]) swap(a,b);</span><br><span class="line">    rig[a]=ltree_merge(rig[a],b);</span><br><span class="line">    root[rig[a]]=a;</span><br><span class="line">    <span class="keyword">if</span>(dist[rig[a]]&gt;dist[lef[a]])</span><br><span class="line">        swap(rig[a],lef[a]);</span><br><span class="line">    <span class="keyword">if</span>(rig[a]==<span class="number">0</span>)</span><br><span class="line">        dist[a]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> dist[a]=dist[rig[a]]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ltree_pop</span><span class="params">(<span class="keyword">int</span> k)</span><span class="comment">//左偏树删除顶点的操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=lef[k],r=rig[k];</span><br><span class="line">    root[l]=l;root[r]=r;</span><br><span class="line">    lef[k]=rig[k]=dist[k]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ltree_merge(l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tree[k].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=tree[k][i];</span><br><span class="line">        dfs(v);</span><br><span class="line">        sum[k]+=sum[v];</span><br><span class="line">        coun[k]+=coun[v];</span><br><span class="line">        root[k]=root[v]=ltree_merge(root[k],root[v]);<span class="comment">//将两个子树合成一个</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(sum[k]&gt;m)<span class="comment">//维护k点的左偏树</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum[k]-=val[root[k]];</span><br><span class="line">        root[k]=ltree_pop(root[k]);</span><br><span class="line">        coun[k]--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    res=max(res,coun[k]*lead[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> fa;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;fa,&amp;val[i],&amp;lead[i]);</span><br><span class="line">            tree[fa].push_back(i);<span class="comment">//建树</span></span><br><span class="line">            root[i]=i;</span><br><span class="line">            coun[i]=<span class="number">1</span>;</span><br><span class="line">            sum[i]=val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        res=<span class="number">0</span>;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hysbz-2809&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hysbz-2809&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=2809&quot; tar
      
    
    </summary>
    
    
      <category term="ICPC" scheme="https://tlooper.github.io/tags/ICPC/"/>
    
  </entry>
  
  <entry>
    <title>sup-002 利用python执行C程序</title>
    <link href="https://tlooper.github.io/sup-002/"/>
    <id>https://tlooper.github.io/sup-002/</id>
    <published>2018-11-14T13:37:39.000Z</published>
    <updated>2018-11-14T16:03:02.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用python执行c程序"><a class="markdownIt-Anchor" href="#利用python执行c程序"></a> 利用python执行C程序</h1><p>首先python自己是无法真正意义上地去执行C语言的代码的，但是我们可以转换思路，利用python调用外部程序来实现。</p><h2 id="0配置环境变量"><a class="markdownIt-Anchor" href="#0配置环境变量"></a> 0.配置环境变量</h2><p>由于需要调用编译器进行程序的编译运行，故需要在环境变量path中添加编译器地址。</p><blockquote><p>如何找到编译器地址？以codeblocks 为例：在 \CodeBlocks\MinGW\bin 目录下有g++.exe,其他编译器自行手动搜索</p></blockquote><p>配置环境变量：此电脑-&gt;属性-&gt;(左侧栏的)高级系统设置-&gt;高级-&gt;环境变量<br>　　双击Path，添加编译器的地址在最后</p><h2 id="1subprocesscall"><a class="markdownIt-Anchor" href="#1subprocesscall"></a> 1.subprocess.call()</h2><blockquote><p>虽然有个os的模块同样有os.system()函数来实现执行命令行的操作，但是似乎目前已经被subprocess取代了，同时subprocess 模块的使用灵活度比os大得多，所以在此只介绍使用subprocess模块的情况</p></blockquote><p><strong>如果是Linux系统请下载subprocess32,<code>sudo pip install subprocess32</code></strong></p><p>显然使用这个函数需要包含<code>subprocess</code>的模块，括号中包含的字符串就是你平时在命令提示符窗口输入的指令，除了字符串似乎还支持list<s>不过我不需要</s>。如果是用codeblocks的话可以看到，在编译运行的时候，运行日志的前两行输出了命令行，代码示例：</p><p class="code-caption" data-lang="python" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">subprocess.call(<span class="string">"mingw32-gcc.exe   -c test.c -o test.o"</span>)</span><br><span class="line">subprocess.call(<span class="string">"mingw32-g++.exe  -o test.exe test.o"</span>)</span><br></pre></td></tr></table></figure><p>Linux下的代码：（确保已经安装g++/gcc）</p><p class="code-caption" data-lang="python" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subprocess.call(<span class="string">"g++ test.cpp -o test"</span>)</span><br></pre></td></tr></table></figure><p>当然光是编译运行是不够的，我们要能执行C程序，还要提供输入与输出。如果是直接用<code>subprocess.call(&quot;test.exe&quot;)</code>，系统默认的输入输出跟python程序的输入输出一样。我们也可以指定从文件输入输出<s>就像是打ACM一样</s>：</p><p class="code-caption" data-lang="python" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">inp=open(<span class="string">"in.txt"</span>,<span class="string">"r"</span>)</span><br><span class="line">out=open(<span class="string">"res.txt"</span>,<span class="string">"w"</span>)</span><br><span class="line">subprocess.call(<span class="string">"test.exe"</span> , stdin=inp,stdout=out)</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用python执行c程序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#利用python执行c程序&quot;&gt;&lt;/a&gt; 利用python执行C程序&lt;/h1&gt;
&lt;p&gt;首先python自己是无法真正意义上地去执行C语言的代码的，但是我们可以转换思
      
    
    </summary>
    
    
      <category term="skill" scheme="https://tlooper.github.io/tags/skill/"/>
    
  </entry>
  
  <entry>
    <title>introduction</title>
    <link href="https://tlooper.github.io/introduction/"/>
    <id>https://tlooper.github.io/introduction/</id>
    <published>2018-09-10T12:15:47.000Z</published>
    <updated>2018-09-14T10:54:31.505Z</updated>
    
    <content type="html"><![CDATA[<p>“    <strong>人类到如今已经繁衍了250000年，只有最近的100年是有网络的。</strong><br>所以，我们在将近250000年中在干嘛？我们用最原始的方式交流、学习，信息在传递中改变、散佚，我们无从得知曾经有过怎样的技术、知识，事实与传说混杂在一起。<br>之后，网络将人类连接起来，人与人之间的信息交流从未如此快速、准确。人类过剩的创造力带来了数不胜数的信息片段，部分片段随着时间推移也如传说般变得模糊不清。<br>**人类不能再生活在信息匮乏的笼子里。**如果信息获取被阻止，我们就创造信息。<br>当他人甘于无知时，我们必须花时间搜集、创造知识，并将它们保存下来，寄希望于后人能接替我们的事业。<br><strong>我们搜集，我们理解，我们制造。</strong>”<br>——O5-T</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“    &lt;strong&gt;人类到如今已经繁衍了250000年，只有最近的100年是有网络的。&lt;/strong&gt;&lt;br&gt;
所以，我们在将近250000年中在干嘛？我们用最原始的方式交流、学习，信息在传递中改变、散佚，我们无从得知曾经有过怎样的技术、知识，事实与传说混杂在一起。
      
    
    </summary>
    
    
      <category term="introduction" scheme="https://tlooper.github.io/tags/introduction/"/>
    
  </entry>
  
</feed>
